---
title: Nav2
description: Path planning for bipedal humanoid movement using Nav2.
slug: /module-03-ai-brain/nav2
tags: [robotics, ai, nav2, ros, path-planning, navigation]
---

## The GPS for Robots
Nav2, the ROS 2 Navigation Stack, is a powerful and flexible framework for enabling mobile robots to autonomously navigate complex environments. While initially designed for wheeled robots, its modular architecture makes it adaptable for various locomotion types, including the challenging domain of bipedal humanoid movement. For Physical AI, especially in the context of humanoid robotics, Nav2 is crucial as it provides the high-level decision-making and low-level control necessary for robust path planning, obstacle avoidance, and safe execution of movements. It allows humanoid robots to move purposefully from one point to another, dynamically adjusting to changes in the environment, which is fundamental for human-robot interaction and task completion in human-centric spaces.

## Planning the Journey
Consider a humanoid robot tasked with delivering an object across a room, navigating around furniture and people. Nav2 acts as the robot's strategic planner and tactical executor.
*   **The Brain's GPS**: Nav2 takes the robot's current position (from localization systems like VSLAM), a map of its environment, and a goal location. It then calculates a global, safe route to that goal, much like a car's GPS.
*   **Dynamic Obstacle Avoidance**: As the robot moves, its sensors detect new, unexpected obstacles (like a person walking by). Nav2's local planners instantly adjust the robot's trajectory to avoid collisions, demonstrating reactive intelligence. This is akin to a human instinctively stepping around an unexpected obstruction.
*   **Behavior Orchestration**: Nav2 coordinates various behaviors, such as following a path, stopping when blocked, rotating to observe surroundings, or even recovering from minor deviations. It ensures the robot's movements are not just functional but also safe and efficient.
*   **Adaptability for Humanoids**: While typical Nav2 setups use odometry for wheeled robots, its modular design allows for integration with more complex humanoid locomotion controllers. Instead of sending wheel velocities, it can send footstep plans or center-of-mass trajectories to a bipedal controller. This means Nav2 provides the 'what' (move from A to B safely), and the humanoid's specific motor control system provides the 'how' (walk, balance, step).
In essence, Nav2 provides the intelligent layer that translates high-level mission goals into actionable, safe, and efficient movement commands for the robot's physical body.

## Costmaps & Planners
Nav2 builds upon several fundamental algorithms and theoretical concepts in robotics:
*   **Localization**: Accurate knowledge of the robot's pose (position and orientation) is crucial. Nav2 typically relies on external localization systems like AMCL (Adaptive Monte Carlo Localization) or VSLAM.
*   **Mapping**: Nav2 operates with a map of the environment, often a 2D occupancy grid map, which represents free, occupied, and unknown spaces. This map is generated through SLAM algorithms.
*   **Global Path Planning**: These algorithms compute a collision-free path from the robot's start location to a goal location, considering the static obstacles in the map.
    *   **Dijkstra's Algorithm**: Finds the shortest path between nodes in a graph.
    *   **A* (A-star) Algorithm**: An extension of Dijkstra's that uses a heuristic function to guide its search, making it more efficient. The cost function is typically:
        $$ f(n) = g(n) + h(n) $$
        where $$f(n)$$ is the total estimated cost of path through node $$n$$, $$g(n)$$ is the cost from start to $$n$$, and $$h(n)$$ is the heuristic estimate of cost from $$n$$ to goal.
    *   **Sampling-based Planners (e.g., RRT, PRM)**: For high-dimensional or complex environments, these probabilistically explore the configuration space.
*   **Local Path Planning (Trajectory Generation)**: These algorithms generate a short-term, dynamically feasible trajectory that avoids nearby static and dynamic obstacles while attempting to follow the global path.
    *   **Dynamic Window Approach (DWA)**: Samples valid velocities for the robot and simulates forward trajectories to choose the best one based on an objective function (e.g., clearance from obstacles, progress towards goal).
    *   **Timed-Elastic Band (TEB) Local Planner**: Optimizes the robot's trajectory by considering path length, obstacle avoidance, and dynamic constraints (velocity, acceleration).
*   **Behavior Trees**: Nav2 uses Behavior Trees for orchestrating different navigation behaviors (e.g., "GoToPose", "Wait", "Spin"). These provide a structured way to define complex robot behaviors and handle failures gracefully.
*   **Control Theory**: Lower-level control loops (e.g., PID controllers) are often used to ensure the robot accurately follows the generated trajectories. For humanoid robots, this is particularly complex, involving balance control and whole-body dynamics.

## The Navigation Stack
Nav2's architecture is highly modular, built around the ROS 2 framework, allowing for flexible configuration and integration of different algorithms. Key components and their interaction form a robust navigation pipeline:
*   **ROS 2 Nodes**: Each functional block within Nav2 (e.g., global planner, local planner, controller, behavior tree) is implemented as a separate ROS 2 node, communicating via topics and services.
*   **Life Cycle Manager**: Nav2 utilizes ROS 2's managed nodes concept, allowing nodes to transition through states (e.g., `unconfigured`, `inactive`, `active`) for reliable system startup and shutdown.
*   **World Model**: Composed of:
    *   **Costmap 2D**: A grid-based representation of the environment, including static obstacles (from map) and dynamic obstacles (from sensor data), used by planners and controllers to assess path costs and detect collisions.
    *   **Map Server**: Provides the static map of the environment.
*   **Behavior Tree (BT) Navigator**: The top-level orchestrator. It uses a Behavior Tree to define the robot's high-level navigation logic, deciding when to plan globally, locally, recover from failures, or execute specific actions.
*   **Global Planner**: Plans a high-level, collision-free path from the robot's current pose to the goal pose on the global costmap (e.g., `NavFn`, `SmacPlanner`).
*   **Local Planner (Controller)**: Generates a dynamically feasible, short-term trajectory that avoids local obstacles and guides the robot along the global path (e.g., `DWAPlannerROS`, `TEBPlannerROS`).
*   **Controller Server**: Executes the local plan, sending velocity commands to the robot's base controller. For humanoid robots, this component would interface with a whole-body control system to translate velocity commands into bipedal locomotion.
*   **Recovery Behaviors**: Modules that activate when the robot gets stuck or encounters an unrecoverable situation (e.g., spinning in place, clearing costmaps).

**Pipeline Overview**:
1.  **Goal Received**: A navigation goal is sent to Nav2.
2.  **Global Plan**: The Behavior Tree triggers a Global Planner to find an optimal path to the goal.
3.  **Local Plan & Control**: The Local Planner generates a local trajectory, and the Controller Server sends commands to the robot.
4.  **Obstacle Avoidance**: Dynamic obstacles are detected via sensor inputs and updated in the costmap, influencing local planning.
5.  **Recovery**: If planning fails or the robot gets stuck, recovery behaviors are initiated.
This iterative process enables autonomous movement while adapting to environmental changes.

## Navigation Flow
This diagram illustrates the high-level architecture of the Nav2 navigation stack, showing the flow from a goal pose to robot actuation, incorporating environmental sensing and planning components.
```mermaid
graph TD
    A[Goal Pose] --> B{Behavior Tree Navigator};
    B -- Global Plan Request --> C(Global Planner);
    C -- Global Path --> D{Controller Server};
    B -- Local Plan Request --> D;
    D -- Local Plan / Trajectory --> E(Robot Controller);
    E -- Velocity Commands --> F[Robot Base / Humanoid Locomotion];
    G[Localization System<br>(e.g., VSLAM)] --> H(Costmap 2D);
    I[Sensor Data<br>(LiDAR, Camera)] --> H;
    H -- Obstacle Data --> D;
    H -- Map Data --> C;
    subgraph Nav2 Stack
        B; C; D; E; H;
    end
```

## A* and DWA
Nav2 allows the configuration of various path planning, control, and recovery algorithms. The primary algorithms are typically integrated as plugins:
*   **Global Planners**:
    *   **A* (A-star)**: A graph traversal and path search algorithm.
        *   **Pseudocode for A* Search**:
            ```
            function A_STAR(start, goal):
                open_set = {start}
                came_from = {}
                g_score = {node: infinity for all nodes}
                g_score[start] = 0
                f_score = {node: infinity for all nodes}
                f_score[start] = heuristic(start, goal)

                while open_set is not empty:
                    current = node in open_set with lowest f_score
                    if current == goal:
                        return reconstruct_path(came_from, current)

                    open_set.remove(current)
                    for neighbor in get_neighbors(current):
                        tentative_g_score = g_score[current] + cost(current, neighbor)
                        if tentative_g_score < g_score[neighbor]:
                            came_from[neighbor] = current
                            g_score[neighbor] = tentative_g_score
                            f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)
                            if neighbor not in open_set:
                                open_set.add(neighbor)
                return failure
            ```
    *   **Dijkstra's**: Finds the shortest path between nodes in a graph, without heuristics.
    *   **SmacPlanner**: An optimized hybrid A* planner particularly effective for car-like robots, which can also be adapted for bipedal movement with suitable motion primitives.
*   **Local Planners (Controllers)**:
    *   **Dynamic Window Approach (DWA)**: Selects the best velocity command by sampling velocities, simulating robot motion, and evaluating trajectories based on an objective function (e.g., clearance, velocity, progress to goal).
        *   **High-Level DWA Process**:
            1.  Sample velocities ($$v, \omega$$) within dynamic window.
            2.  Simulate forward trajectory for each ($$v, \omega$$).
            3.  Evaluate each trajectory (goal proximity, obstacle clearance, velocity).
            4.  Select ($$v, \omega$$) pair with best score.
    *   **Timed-Elastic Band (TEB)**: Optimizes the entire trajectory by simultaneously considering robot dynamics, obstacle avoidance, and goal reachability.
*   **Behavior Trees**: Used for complex reactive and deliberative control logic. A BT is a hierarchical structure that defines a robot's behavior by combining simple tasks (nodes) into complex sequences. Nodes include:
    *   **Sequence**: Executes children in order until one fails or all succeed.
    *   **Selector**: Executes children in order until one succeeds or all fail.
    *   **Parallel**: Executes all children simultaneously.

## Configuring the Stack
This is a simplified ROS 2 launch file for the Nav2 stack, showing how the core components might be started for a generic robot. In a humanoid context, the `controller_server` would interface with a bipedal locomotion controller.

```python
import os
from ament_index_python.packages import get_package_share_directory
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription
from launch.launch_description_sources import PythonLaunchDescriptionSource
from launch.substitutions import LaunchConfiguration, PythonExpression
from launch_ros.actions import Node
from nav2_common.launch import RewrittenYaml


def generate_launch_description():
    # Get the launch directory
    nav2_bringup_dir = get_package_share_directory('nav2_bringup')
    
    # Create the launch configuration variables
    namespace = LaunchConfiguration('namespace')
    use_sim_time = LaunchConfiguration('use_sim_time')
    autostart = LaunchConfiguration('autostart')
    params_file = LaunchConfiguration('params_file')
    map_subscribe_transient_local = LaunchConfiguration('map_subscribe_transient_local')
    
    # --- Default Parameters ---
    default_map_yaml_file = os.path.join(nav2_bringup_dir, 'maps', 'turtlebot3_world.yaml') # Example map
    default_params_file = os.path.join(nav2_bringup_dir, 'params', 'nav2_params.yaml') # Example params
    
    # --- Remapping for Nav2 with Humanoid Locomotion (Conceptual) ---
    # In a real humanoid, '/cmd_vel' would be remapped to a topic
    # understood by the humanoid's locomotion controller (e.g., '/humanoid_controller/cmd_footsteps')
    # and localization data would come from a VSLAM system (e.g., '/vslam/robot_pose')

    lifecycle_nodes = ['map_server',
                       'amcl', # Or VSLAM_node outputting poses
                       'controller_server',
                       'smoother_server',
                       'planner_server',
                       'behavior_server',
                       'bt_navigator',
                       'waypoint_follower',
                       'velocity_smoother']

    # Create our own temporary YAML files that include substitutions
    # This is useful for passing arguments to the RewrittenYaml
    configured_params = RewrittenYaml(
            source_file=params_file,
            root_key=namespace,
            param_rewrites={'use_sim_time': use_sim_time},
            convert_types=True)

    return LaunchDescription([
        # Declare launch arguments
        DeclareLaunchArgument(
            'namespace', default_value='',
            description='Top-level namespace'),
        DeclareLaunchArgument(
            'use_sim_time', default_value='true',
            description='Use simulation (Gazebo) clock if true'),
        DeclareLaunchArgument(
            'autostart', default_value='true',
            description='Automatically startup the nav2 stack'),
        DeclareLaunchArgument(
            'params_file',
            default_value=default_params_file,
            description='Full path to the ROS2 parameters file to use for all launched nodes'),
        DeclareLaunchArgument(
            'map_subscribe_transient_local', default_value='false',
            description='Whether to set the map subscriber QoS to transient local'),

        # Include the main Nav2 launch file
        IncludeLaunchDescription(
            PythonLaunchDescriptionSource(os.path.join(nav2_bringup_dir, 'launch', 'bringup_launch.py')),
            launch_arguments={
                'namespace': namespace,
                'use_sim_time': use_sim_time,
                'autostart': autostart,
                'params_file': configured_params,
                'map': default_map_yaml_file,
                'use_composition': 'True',
                'container_name': 'nav2_container',
                'map_subscribe_transient_local': map_subscribe_transient_local}.items(),
        ),

        # This is where a humanoid-specific controller might be integrated
        # For example, remapping the cmd_vel topic to a custom locomotion controller
        # Node(
        #     package='humanoid_locomotion_controller',
        #     executable='humanoid_cmd_vel_translator',
        #     name='humanoid_cmd_vel_translator_node',
        #     remappings=[('/cmd_vel', '/humanoid_controller/cmd_footsteps')],
        #     parameters=[{'use_sim_time': use_sim_time}],
        #     output='screen'
        # )
    ])
```
**Note**: This is a high-level conceptual example for setting up Nav2. For an actual humanoid robot, a custom `controller_server` plugin would likely be needed to interface with the robot's bipedal locomotion controller, translating Nav2's path commands into suitable balance and movement commands for the humanoid. The localization input (typically from AMCL) would ideally come from a VSLAM system like Isaac ROS VSLAM.

## Moving Safely
Nav2's robust navigation capabilities extend to numerous real-world robotic applications:
*   **Autonomous Mobile Robots (AMRs) in Logistics**: Guiding robots to transport goods in warehouses and factories, optimizing routes, and avoiding dynamic obstacles like human workers or other robots.
*   **Humanoid Robot Navigation**: Enabling bipedal robots to move through human-centric environments (homes, offices, hospitals) by planning stable footstep sequences and avoiding collisions, essential for tasks like assistance, delivery, or inspection. The code example shows a conceptual integration with humanoid locomotion.
*   **Service Robotics**: Allowing robots in public spaces (e.g., airports, malls) to autonomously move to their service points, interact with people, and navigate dynamic crowds safely.
*   **Exploration and Inspection Robots**: Directing robots in hazardous or inaccessible environments (e.g., collapsed buildings, underwater exploration) to gather data, build maps, and perform specified tasks.
*   **Agricultural Robots**: Guiding autonomous tractors or harvesting robots through fields, optimizing paths for efficiency and avoiding unexpected obstacles.
*   **Research Platforms**: Providing a standard, flexible navigation framework for academic and industrial researchers to develop and test new planning, control, and localization algorithms on a variety of robot platforms.

## Getting Stuck
Implementing and tuning Nav2, especially for complex platforms like humanoid robots, involves several challenges and inherent design trade-offs:
*   **Parameter Tuning Complexity**: Nav2 has numerous configurable parameters for its global planners, local planners, and costmaps. Optimally tuning these for a specific robot and environment can be a time-consuming and iterative process, often requiring empirical testing. Trade-off: flexibility vs. ease of configuration.
*   **Sensor Data Quality**: Nav2's performance is highly dependent on the quality and accuracy of input sensor data (localization, obstacle detection). Noisy or inaccurate sensor readings can lead to poor localization, jerky movements, or collisions. Trade-off: cost/complexity of high-fidelity sensors vs. robustness of navigation.
*   **Humanoid Locomotion Integration**: Adapting Nav2, primarily designed for wheeled robots, to bipedal humanoid movement is a significant challenge. It requires a robust interface between Nav2's velocity commands (or desired poses) and the humanoid's complex locomotion controller, which must maintain balance and stability. This often means custom `ControllerServer` plugins. Trade-off: generic solution vs. specialized humanoid-specific control.
*   **Dynamic Obstacles Handling**: While Nav2 can handle dynamic obstacles, rapidly changing environments or highly unpredictable moving objects (e.g., dense crowds) can still pose challenges for real-time re-planning and collision avoidance, especially at higher speeds. Trade-off: responsiveness vs. computational load.
*   **Computational Resources**: Running a full Nav2 stack with multiple planners, controllers, and costmaps, alongside localization and perception systems, can be computationally intensive, requiring sufficient CPU and memory resources.
*   **Map Accuracy and Maintenance**: The accuracy of the static map is critical. Errors or outdated information in the map can lead to planning failures. Maintaining maps in dynamic environments is an ongoing challenge.

## Lab: Point-to-Point Navigation
**Task Description**: Set up a basic Nav2 stack in a simulated environment (e.g., using Gazebo or Isaac Sim with ROS 2 bridge). Launch a simple robot (e.g., TurtleBot3) with Nav2 configured, and command it to navigate to a series of goal poses in a known map.
**Expected Output**: The simulated robot should successfully navigate to the specified goal poses, avoiding obstacles. The robot's path and perception of its environment should be visualized in RViz.
**Tools Required**: ROS 2 (Humble or later), Nav2 stack, Gazebo (or Isaac Sim with ROS 2 bridge), `turtlebot3_gazebo` (for example robot), RViz.

## Summary
*   **Nav2 Overview**: The ROS 2 Navigation Stack, providing autonomous navigation for mobile robots, adaptable to humanoid locomotion.
*   **Key Capabilities**: Global and local path planning, dynamic obstacle avoidance, and behavior orchestration using Behavior Trees.
*   **Modular Architecture**: Composed of ROS 2 nodes for localization, mapping, planning, and control, interacting via Costmap 2D.
*   **Humanoid Integration**: Requires interfacing with specialized locomotion controllers to translate Nav2 commands into bipedal movement.

**Conceptual Checkpoints**:
1.  Describe the roles of global and local planners within the Nav2 stack.
2.  Explain how Nav2 adapts to dynamic obstacles in real-time.
3.  Identify a key challenge in integrating Nav2 with a bipedal humanoid robot.

## Further Reading
**Papers**:
*   [ROS 2 Navigation Stack Documentation](https://navigation.ros.org/)
*   [Nav2: Adaptive Behavior Tree-based Navigation for ROS 2](https://ieeexplore.ieee.org/document/9560419) by Macenski et al. (2021).

**Books**:
*   *Programming Robots with ROS* by Morgan Quigley, Brian Gerkey, and William Smart. (Covers ROS fundamentals, useful for Nav2 context).

**Open-source projects**:
*   **Nav2**: The official GitHub repository for the ROS 2 Navigation Stack.
*   **ROS 2**: The core framework for developing robot applications.
*   **Gazebo**: A popular 3D robotics simulator often used with ROS and Nav2.
